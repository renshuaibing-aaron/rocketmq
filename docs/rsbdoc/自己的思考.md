1.rocketmq的文件存储的优势是什么？底层原理是什么？
MappedByteBuffer 是java零拷贝的原理  然后这个和直接内存又是啥关系？



2.值得注意的是在集群的情况下,每个消息队列只能被一个消费者消费 这说明加入消费者比消息队列比较多的话  有可能消费者消费不到消息,  这样做的原因是 在集群模式在，消息队列
进行负载均衡到消费者，假如消息队列能被两个消费者消费，不符合集群模式的理念
但是对于广播模式没有这个限制,在广播模式下面 消费队列必须分发到所有的消费者



3.rocketMq中的组件太多 这写组件中间到底是怎么通信的？长连接 短连接？


4.利用rocketMq怎么实现幂等性？

messageID 不靠谱的家伙 需要用户自己实现 可以利用redis


5.producer 生产者发送消息后 没有必要和rocketmq断开连接 但是在你的程序退出的时候 需要保证执行producer的shutdown方法 释放资源



6.nameServer组中各个服务器之间并不通信 怎么保证系统的高可用性 每个broker和每个nameServer都保持长连接 也就是在nameServer内部保证整个项目的所有结构 
真是尼玛简单  在nameServer内部保存的信息是什么？
每个topic可以创建多个消息队列  然后分到各个broker上面,每个broker会为每个topic创建4个读队列和4个写队列 这里的读队列写对列是什么？


6.同步刷盘和异步刷盘的原理 
 为啥需要刷盘 发送消息后 消息已经在内存了(直接内存实现零拷贝)  需要在磁盘上进行持久化操作   这里也说明一点 这里其实本质是采用虚拟内存 
 使得用户内存和内核态缓冲区的共享 然后进行刷盘操作 持久化到内存





7.



























































